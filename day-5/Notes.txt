

Python Code Organization 
--------------------------

Level 1: Single File Problem - Why We Need Organization
------------------------------------------

Explaining Points:

Problem: Everything in one file becomes messy
Real scenario: NPCI has accounts, transactions, gateways - can't be in one file
Solution: Split code into logical units
As projects grow, organization becomes critical

--
Problems with this approach:
1. Hard to find specific code
2. Can't reuse in other projects
3. Testing is difficult
4. Multiple developers can't work easily
5. Name conflicts possible
6. 1000+ lines become unmanageable
--

Level 2: Modules - Splitting Into Files
------------------------------------------

### Explaining Points:
- **Module** = A Python file (.py)
- **import** = Brings code from another file
- Each module has specific responsibility
- Like departments in NPCI - each has a role

npci_project/
│
├── accounts.py       # Account-related classes
├── transactions.py   # Transaction handling
├── gateways.py       # Payment gateways
├── utils.py          # Utility functions
└── main.py           # Main application

Key Benefits of Modules:

✓ Organized - Each file has clear purpose
✓ Reusable - Can import in multiple projects
✓ Maintainable - Easy to find and fix bugs
✓ Collaborative - Different developers work on different modules
✓ Testable - Each module can be tested separately


Level 3: Different Import Styles
------------------------------------------
Explaining Points:

Multiple ways to import
Each has use cases
Choose based on readability and naming conflicts


Level 4: Packages - Organizing Multiple Modules**

### Explaining Points:
- **Package** = Directory containing modules
- Must have `__init__.py` file
- Creates namespace hierarchy
- Like organizing departments in NPCI building

### Project Structure:
```
npci_payment_system/
│
├── npci/                     # Main package
│   ├── __init__.py           # Makes it a package
│   │
│   ├── accounts/             # Sub-package for accounts
│   │   ├── __init__.py
│   │   ├── base.py           # Base account class
│   │   ├── savings.py        # Savings account
│   │   └── current.py        # Current account
│   │
│   ├── payments/             # Sub-package for payments
│   │   ├── __init__.py
│   │   ├── upi.py            # UPI gateway
│   │   ├── imps.py           # IMPS gateway
│   │   └── neft.py           # NEFT gateway
│   │
│   ├── transactions/         # Sub-package for transactions
│   │   ├── __init__.py
│   │   ├── transaction.py    # Transaction class
│   │   └── history.py        # Transaction history
│   │
│   └── utils/                # Utilities sub-package
│       ├── __init__.py
│       ├── validators.py     # Validation functions
│       └── formatters.py     # Formatting functions
│
├── tests/                    # Test files
│   ├── test_accounts.py
│   ├── test_payments.py
│   └── test_transactions.py
│
├── config/                   # Configuration files
│   └── settings.py
│
└── main.py                   # Main application


--------------

Before Python 3.3, a folder had to contain __init__.py to be considered a package.
---
__init__.py marks a directory as a Python package.
It controls what is visible when the package is imported.
It can run initialization code when the package loads.
Still recommended today for clear, maintainable package structure.


---

### Key Benefits of Packages:
1. ✓ **Hierarchical organization** - Clear structure
2. ✓ **Namespace management** - Avoid name conflicts
3. ✓ **Selective imports** - Import only what you need
4. ✓ **Scalability** - Easy to add new sub-packages
5. ✓ **Team collaboration** - Different teams work on different packages
6. ✓ **Code reusability** - Can import package in other projects


---


Level 5: Virtual Environments - Isolated Python Worlds
----------------------------------------

### Explaining Points:
- **Problem**: Different projects need different package versions
- **Virtual Environment** = Isolated Python installation
- Each project has its own dependencies


### Why Virtual Environments?

**Scenario Without Virtual Environment:**
```
System Python (Global)
│
├── Project A (UPI System) - needs requests==2.25.0
├── Project B (IMPS System) - needs requests==2.28.0  ❌ CONFLICT!
└── Project C (Testing) - needs pytest==6.0.0

**Problem**: Can't have two versions of same package!

**Scenario With Virtual Environments:**
```
System Python (Global)
│
├── venv_upi/          # Virtual env for UPI
│   └── requests==2.25.0  ✓
│
├── venv_imps/         # Virtual env for IMPS
│   └── requests==2.28.0  ✓
│
└── venv_testing/      # Virtual env for Testing
    └── pytest==6.0.0  ✓

---
Python Virtual Environment Tools:
1. `venv` - Built-in, simple to use
2. `virtualenv` - More features, works with older Python versions
3. `pipenv` - Combines package management and virtual environments
4. `conda` - Manages environments and packages, popular in data science

python package management tools:
1. `pip` - Default package manager
2. `poetry` - Modern dependency management and packaging
---




__init__.py

Expose selected modules:

from .database import connect
from .utils import helper


Define what 'from package import *' should import:

__all__ = ["connect", "helper"]